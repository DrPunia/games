<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Flippin — Real-time</title>
<style>
  /* minimal styles (same as before, mobile-optimized) */
  *{box-sizing:border-box;margin:0;padding:0}
  body{font-family:Calibri, sans-serif;font-size:14px;background:#ffbba7;padding:1rem;display:flex;flex-direction:column;align-items:center}
  h1{font-size:1.4rem;margin-bottom:0.8rem}
  .controls{background:#fff;padding:0.6rem;border-radius:8px;width:100%;max-width:520px;margin-bottom:0.8rem;text-align:center}
  input{padding:8px;border-radius:6px;border:1px solid #ccc;margin:4px}
  button{padding:8px 10px;border-radius:6px;background:#2b6ef6;color:#fff;border:0;cursor:pointer;margin-left:6px}
  #timer{font-size:1.1rem;margin-bottom:8px}
  .game-container{width:100%;max-width:520px;display:flex;flex-direction:column;align-items:center}
  .players{display:flex;justify-content:space-between;width:100%;margin-bottom:8px}
  .player{background:#fff;padding:8px;border-radius:6px;flex:1;margin:0 6px;text-align:center}
  .board{display:grid;grid-template-columns:repeat(auto-fit,minmax(60px,1fr));gap:8px;width:100%}
  .card{position:relative;padding-top:100%;border-radius:8px;background:#FFF0E0;cursor:pointer;perspective:800px}
  .card-inner{position:absolute;inset:0;transition:transform 300ms;transform-style:preserve-3d}
  .card.revealed .card-inner{transform:rotateY(180deg)}
  .face,.back{position:absolute;inset:0;border-radius:8px;display:flex;align-items:center;justify-content:center;backface-visibility:hidden}
  .face{transform:rotateY(180deg);flex-direction:column}
  .emoji{font-size:2.6rem}
  #log{width:100%;margin-top:8px;background:#fff;padding:8px;border-radius:6px;max-height:180px;overflow:auto}
  .log-item{font-size:13px;margin-bottom:6px}
</style>
</head>
<body>
  <h1>Flippin (Real-time)</h1>

  <div class="controls">
    <input id="nameInput" placeholder="Your name" />
    <input id="roomInput" placeholder="Room id (or leave blank to create)" />
    <button id="btnCreate">Create Room</button>
    <button id="btnJoin">Join Room</button>
    <div id="status" style="margin-top:8px;color:#444"></div>
  </div>

  <div id="timer">Time: 05:00</div>

  <div class="game-container" id="game" style="display:none">
    <div class="players" id="players"></div>
    <div id="pairsFound" style="margin:8px 0">Pairs found: 0 / 10</div>
    <div class="board" id="board"></div>
    <div id="log"></div>
  </div>

  <!-- Socket.IO client (CDN) -->
  <script src="https://cdn.socket.io/4.8.1/socket.io.min.js"></script>
  <script>
    // ====== CONFIG ======
    const SOCKET_SERVER_URL = 'https://flippin-server.onrender.com';
    socket.on('connect_error', err => {
  console.error('Connection error:', err);
  alert('Unable to connect to server — check the console for details.');
});
    const socket = io(SOCKET_SERVER_URL, { transports: ['websocket','polling'] });

    // ====== UI refs ======
    const nameInput = document.getElementById('nameInput');
    const roomInput = document.getElementById('roomInput');
    const btnCreate = document.getElementById('btnCreate');
    const btnJoin = document.getElementById('btnJoin');
    const statusEl = document.getElementById('status');
    const gameEl = document.getElementById('game');
    const playersEl = document.getElementById('players');
    const boardEl = document.getElementById('board');
    const logEl = document.getElementById('log');
    const timerEl = document.getElementById('timer');
    const pairsFoundEl = document.getElementById('pairsFound');

    let myName = '';
    let myRoom = '';
    let myPlayerIndex = -1; // 0 or 1 as server assigns
    let state = null;

    function log(msg){
      const d = document.createElement('div'); d.className='log-item'; d.textContent = msg;
      logEl.prepend(d);
    }

    // UI actions
    btnCreate.onclick = () => {
      myName = (nameInput.value || 'Player 1').trim();
      socket.emit('createRoom', (res) => {
        if (res && res.roomId) {
          myRoom = res.roomId;
          // after create, join as created player already handled server-side; ask user to share room id
          statusEl.textContent = `Room created: ${myRoom}. Share this id with opponent.`;
          // we are already in room but server created only player1. We need to update name (optional)
          socket.emit('joinRoom', { roomId: myRoom, name: myName }, (r) => {
            // server accepts second join as well; but for created room we might get returned state
            // show game area: actual state will arrive via 'state' event
          });
        } else {
          statusEl.textContent = 'Error creating room';
        }
      });
    };

    btnJoin.onclick = () => {
      myName = (nameInput.value || 'Player').trim();
      const roomId = (roomInput.value || '').trim();
      if (!roomId) { statusEl.textContent = 'Enter a room id to join'; return; }
      myRoom = roomId;
      socket.emit('joinRoom', { roomId: myRoom, name: myName }, (res) => {
        if (res && res.error) {
          statusEl.textContent = 'Join error: ' + res.error;
        } else {
          statusEl.textContent = `Joined room ${myRoom}`;
        }
      });
    };

    // When server sends state, replace UI
    socket.on('state', (s) => {
      state = s;
      // Find my index
      if (s && s.players){
        myPlayerIndex = s.players.findIndex(p => p.name === myName);
        // if name match fails (names not unique) set 0/1 by socket id info is not available here;
        // Show players and stats:
        playersEl.innerHTML = '';
        s.players.forEach((p, i) => {
          const el = document.createElement('div'); el.className='player';
          if (i === s.currentPlayer) el.style.outline='2px solid #f39c12';
          el.innerHTML = `<strong>${p.name}</strong><br>Matches: ${p.matches}<br>Q left: ${5 + (p.extra||0) - (p.asked||0)}`;
          playersEl.appendChild(el);
        });
      }
      renderBoard(s.cards || []);
      // update pairs found
      const matches = (s.players || []).reduce((sum,p)=> sum + (p.matches||0), 0);
      pairsFoundEl.textContent = `Pairs found: ${matches} / 10`;
      // show timer state if provided
      if (s.timer) timerEl.textContent = `Time: ${formatTime(s.timer.remaining)}`;
      // show log
      if (s.log && s.log.length){
        // render top 6
        logEl.innerHTML = '';
        s.log.slice(0,12).forEach(item => {
          log(item.type === 'q' ? `${item.by} asked: ${item.text}` : item.type === 'a' ? `${item.by} answered: ${item.text}` : item.text);
        });
      }
      gameEl.style.display = 'flex';
    });

    socket.on('timer', remaining => {
      timerEl.textContent = `Time: ${formatTime(remaining)}`;
    });
    socket.on('timerPaused', ()=> log('Timer paused'));
    socket.on('timeUp', ()=> { alert('Time is up!'); });
    socket.on('askQuestion', ({ remaining }) => {
      // server tells this player to ask
      pauseLocalTimer(); // precaution
      const q = prompt(`You got to ask a question (left: ${remaining}). Type question:`);
      if (q) socket.emit('askQuestion', { roomId: myRoom, text: q });
      else socket.emit('askQuestion', { roomId: myRoom, text: '' });
    });

    socket.on('questionForAnswer', ({ from, text }) => {
      pauseLocalTimer();
      const ans = prompt(`${from} asks: "${text}". Your answer:`);
      socket.emit('answerQuestion', { roomId: myRoom, text: ans || '' });
    });

    socket.on('questionAnswered', ({ by, text }) => {
      log(`${by} answered: ${text}`);
    });

    socket.on('noQuestions', () => alert('No questions remaining'));

    // Render board function: shows emoji only when revealed or matched
    function renderBoard(cards){
      boardEl.innerHTML = '';
      cards.forEach((c, idx) => {
        const card = document.createElement('div');
        card.className = 'card' + ((c.revealed || c.matched) ? ' revealed' : '');
        card.innerHTML = `<div class="card-inner"><div class="back"></div><div class="face"><div class="emoji">${c.emoji}</div><div class="name">${c.animal}</div></div></div>`;
        boardEl.appendChild(card);
        if (!c.revealed && !c.matched){
          card.addEventListener('click', () => {
            // emit flip to server
            socket.emit('flip', { roomId: myRoom, idx }, (res) => {
              if (res && res.error) {
                // e.g., not your turn
                log('Flip rejected: ' + res.error);
              }
            });
          });
        }
      });
    }

    // Utility
    function formatTime(sec){
      const m = String(Math.floor(sec/60)).padStart(2,'0'), s = String(sec%60).padStart(2,'0');
      return `${m}:${s}`;
    }

    // Local pause/resume placeholders (server decides real timer)
    function pauseLocalTimer(){ /* UI already paused by server events, no-op */ }
    function resumeLocalTimer(){ /* UI resumes via server 'timer' events */ }

    // connection errors
    socket.on('connect_error', (err) => {
      statusEl.textContent = 'Socket connect error';
      console.error(err);
    });

    // show initial message
    statusEl.textContent = 'Enter name and create or join a room.';
  </script>
</body>
</html>
